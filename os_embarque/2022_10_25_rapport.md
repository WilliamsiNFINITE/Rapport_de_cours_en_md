# Compte rendu du TP2 : Ordonnancement

Ce rapport documente la manière dont j'ai réalisé le TP2 sur l'ordonnancement.

## Sommaire

* [Exercice 1](#exercice-1)
* [Exercice 2](#exercice-2)
* [Exercice 3](#exercice-3)
* [Exercice 4](#exercice-4)
* [Exercice 5](#exercice-5)

## Exercice 1
Créez un programme dans lequel vous visualiserez selon deux méthodes différentes les propriétés de l’ordonnancement du processus :

- a. En invoquant les appels spécifiques à l’ordonnancement (getpriority()).

Voici le code que j'ai utilisé afin de changer la priorité du processus. Le pid du processus est donné en paramètres.

```C
int main(int argc, char *argv[]) {
    int priority = 0;
    int settedPriority = 0;
    int id = atoi(argv[1]);

    // visualisation des propriétés d'ordonnacement du processus avec getpriority()
    priority = getpriority(PRIO_PROCESS, id);
    printf("priorité du processus : %d \n", priority);

    return 0;

}
```
Avec un processus dont le pid a été déterminé avec la commande ps, j'obtiens le résultat ci dessous :

```console
[hwilliams@localhost OSembarqueTP2]$ ./exo1 37424
priorité du processus : 0 

```


- b. En passant par le répertoire /proc. Pour accéder via un appel à une fonction au répertoire relatif au processus en cours d’exécution : /proc/self

Avec le code ci-dessous, le résultat que le meme que précedemment.

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_SIZE  255


int main(int argc, char *argv[]) {

    FILE *fp;
    char path[MAX_SIZE];
    int pid = atoi(argv[1]);
    char buffer[MAX_SIZE];
    int position = 0;


    //on ouvre le fichier /proc/pid/stat
    sprintf(path, "/proc/%d/stat", pid);
    fp = fopen(path, "r");
    if (fp == NULL) {
        perror("fopen");
        return;
    }

    // utilisation de strtok pour avoir la priorité (18eme position)
    if (fgets(buffer, MAX_SIZE, fp) != NULL) {
        char* token;
        char* rest = buffer;
        while (token = strtok_r(rest, " ", &rest)){
            if (position == 18){
                printf("priorité du processus : %s \n", token);
            }
            position++;
        }

    }

    return (0);
}

```



## Exercice 2
Augmentez la priorité statique (setpriority()) du processus et visualisez cette dernière (nécessite le mot de passe root).

Voici le code que j'ai utilisé afin de changer la priorité du processus. Le pid du processus et la priorité qu'on souhaite lui attribuer sont donnés en paramètres.

```C
int main(int argc, char *argv[]) {
    int priority = 0;
    int settedPriority = 0;
    int id = atoi(argv[1]);
    int targetPriority = atoi(argv[2]);

    // visualisation des propriétés d'ordonnacement du processus avec getpriority()
    priority = getpriority(PRIO_PROCESS, id);
    printf("priorité initiale du processus : %d \n", priority);

    // modification de la prioritée du processus avec setpriority()
    // ATTENTION ! POUR QUE LA PRIORITÉ SOIT BIEN MODIFIÉE, IL FAUT QUE LE PROCESSUS AIT LES DROITS ROOT (FAIRE UN SUDO)
    settedPriority = setpriority(PRIO_PROCESS, id, targetPriority);
    printf("prioprité visée : %d, retour de la fonction : %d \n", targetPriority, settedPriority);

    // vérification de la modification de la prioritée du processus avec getpriority()
    priority = getpriority(PRIO_PROCESS, id);
    printf("priorité du processus : %d \n", priority);

    return 0;

}
```
Avec un processus dont le pid a été déterminé avec la commande ps, j'obtiens le résultat ci dessous :

```console
[hwilliams@localhost OSembarqueTP2]$ ./exo1 3062
priorité du processus : 0 
[hwilliams@localhost OSembarqueTP2]$ ./exo2 3062 10
priorité initiale du processus : 0 
prioprité visée : 10, retour de la fonction : 0 
priorité du processus : 10 

```

Voilà ce qu'il se produit lorsque je souhaite augmenter le niveau de priorité :

```console
[hwilliams@localhost OSembarqueTP2]$ ./exo2 3062 3
priorité initiale du processus : 10 
prioprité visée : 3, retour de la fonction : -1 
priorité du processus : 10 
```

La commande nécessite le mot de passe root. Je lance une autre fois avec sudo :

```console
[hwilliams@localhost OSembarqueTP2]$ sudo ./exo2 3062 3
priorité initiale du processus : 10 
prioprité visée : 3, retour de la fonction : 0 
priorité du processus : 3 
```

## Exercice 3
Rendez le processus temps réel (FIFO, sched_setscheduler()) et affichez sa priorité (nécessite le mot de passe root, faites un sudo en exécutant le programme).

Le code source est le suivant

```C
#define MAX_SIZE  255

int main(int argc, char *argv[]) {
    int priority = 0;
    int id = atoi(argv[1]);
    struct sched_param param;

    // visualisation des propriétés d'ordonnacement du processus avec getpriority()
    priority = getpriority(PRIO_PROCESS, id);
    printf("priorité initiale du processus : %d \n", priority);

    // on passe le processus en temps réel avec sched_setscheduler() et le parametre FIFO
    // ATTENTION ! POUR QUE LA PRIORITÉ SOIT BIEN MODIFIÉE, IL FAUT QUE LE PROCESSUS AIT LES DROITS ROOT (FAIRE UN SUDO)

    param.sched_priority = 1; //entre 1 et 99 (https://man7.org/linux/man-pages/man2/sched_setscheduler.2.html)
    int ret = sched_setscheduler(id, SCHED_FIFO, &param);
    printf("retour de la fonction : %d \n", ret);

    // vérification de la prioritée du processus avec getpriority()
    priority = getpriority(PRIO_PROCESS, id);
    printf("priorité du processus : %d \n", priority);

    return 0;

}
```

Le résultat est affiché dans la console ci dessous. J'ai remarqué que la priorité n'avait pas changé.

```console
[hwilliams@localhost OSembarqueTP2]$ sudo ./exo3 3653
priorité initiale du processus : 0 
retour de la fonction : 0 
priorité du processus : 0 

```


## Exercice 4
Nous allons essayer, dans cette question, de mesurer le temps de gigue (jitter) des timers de Linux pour les tâches conventionnelles. On fera cela en plusieurs étapes :


- a. Créez, au sein d’un même processus, un timer avec une période d'une seconde en utilisant les fonctions : timer_create(), timer_settime(). Aussi vous utiliserez les signaux et handler de signaux afin d'exécuter les instructions à chaque période.




- b. Faites évoluer le programme de la question précédente pour mesurer le temps auquel s'exécute le handler du signal périodique, puis calculer les différences entre le lancement des signaux contiguës

- c. Afin d’y voir plus clair, on peut analyser les données en calculant la moyenne et l’écart type et en cherchant le min et le max des mesures. 

```console
[hwilliams@localhost archive_aide]$ ./4_c < data-4-b.txt 
 Nb mesures = 5000
 Minimum = -999424
 Maximum = 11342
 Moyenne = 72
 Ecart-type = 31620
```

On remarque qu'on a des temps négatifs. J'ai donc manuellement nettoyé le fichier de résultat afin de n'avoir que des valeurs supérieures ou égales à 0.

- d. On peut aussi tenter de créer un histogramme pour analyser les occurrences de chaque résultat.

Le premier histogramme comporte les valeurs négatives qui ont été enlevées dans le second.


- e. Nous allons tenter de perturber le fonctionnement du programme. En parallèle avec votre programme, exécutez un autre programme sur un terminal séparé. Ce dernier va faire des boucles d'attentes actives puis passer en sommeil d'une manière aléatoire. Refaites les mesures et calculs précédent, que remarquez-vous ?

J'ai compilé et exécuté le code du fichier 4_e_pert.c. Puis, j'ai entré dans un autre terminal les commandes suivantes :

```console
[hwilliams@localhost archive_aide]$ ./4_b 1000 > data-4-e.txt
[hwilliams@localhost archive_aide]$ ./4_c < data-4-e.txt 
 Nb mesures = 5000
 Minimum = -999005
 Maximum = 3968
 Moyenne = 0
 Ecart-type = 31610

```

Là encore j'ai enlevé les valeurs négatives pour former le premier histogramme.



## Exercice 5
A présent, on utilisera des processus temps réel, le processus perturbateur restera en temps partagé, refaites 4-b, 4-c et 4-d, que remarquez-vous ?


